/*

*/

#include <iostream>
using namespace std;

class Hero
{
public:
	string m_name;

	void skill1() { cout << "英雄1技能\n"; }
	void skill2() { cout << "英雄2技能\n"; }
};

class Aixi :public Hero
{
	void skill1() { cout << "艾希1技能\n"; }
	void skill2() { cout << "艾希2技能\n"; }
};

class Daomei :public Hero
{
	void skill1() { cout << "刀妹1技能\n"; }
	void skill2() { cout << "刀妹2技能\n"; }
};

void func(Hero* ptr) {};
void func(Hero& h) {};

int main()
{
}

/*
编译的时候，编译器会直接把成员函数的地址链接到二进制文件中
	但对虚函数不会，而是多了一个隐身的成员，虚函数指针。

在程序创建含虚函数的对象时，除了给成员分配内存，还会创建一个虚函数表
	如果创建的是派生类的对象，在虚函数表中会用派生类成员函数的地址取代基类成员函数的地址
	因此当使用基类指针指向派生类对象，调用虚函数使用的是派生类重写的虚函数

当调用普通函数时，程序的二进制代码中有普通函数的地址，直接执行就行了；
	而调用虚函数，要先查找虚函数表，得到函数的地址，再执行函数。
	因此，调用普通成员函数的效率比调用虚函数更高。

如果基类有虚函数，派生类会从基类中多继承一个虚函数指针和虚函数表
	C++这样设计的目的是让基类和派生类保持相同的内存模型

C++中的多态分为两种:静态多态与动态多态。
	静态多态:也成为编译时的多态;在编译时期就已经确定要执行了的函数地址了;
		主要有函数重载和函数模板。
	动态多态:即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，
		一般用于解决基类指针或引用派生类对象调用类中重写的方法(函数)时出现的问题。
*/